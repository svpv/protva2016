\documentclass[russian,a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage{fullpage}
\usepackage{comment}

\sloppy
\hyphenpenalty=666

\begin{document}
\title{Типизация ABI}
\author{Алексей Турбин}
\date{21 сентября 2016 г.}
\maketitle

\begin{abstract}
Имеющаяся реализация бинарных зависимостей на основе set-версий
позволяет контролировать наличие нужных символов в библиотеках.
Показано, что реализация может быть расширена таким образом,
чтобы учитывался и тип символа, а не только его имя; так чтобы
обеспечивалось не только наличие нужных функций, но и совместимость
их прототипов.
\end{abstract}

\section{Введение}
В предыдущей % неоплаченной
работе \cite{Tourbin2010} показано, что понятие \textit{обратной совместимости}
часто является обманчивым; для достижения реальной \textit{бинарной
совместимости} между библиотеками и программами (ABI) нужно контролировать
не только и не столько придуманные версии библиотек, сколько \textit{разрешимость символов}
(т.\,е. фактическое наличие нужных функций в библиотеках).  Там же обсуждается, насколько
компактным может быть вероятностное представление множеств, при котором каждый
символ представлен $n$-битным хешем.  Вскоре был найден и способ кодирования:
\textit{код Голомба--Райса} обеспечивает оптимальное сжатие дельт (расстояний)
между соседними хешами \cite{Putze2007}.  Таким образом, у библиотек в репозитории появились
зависимости вида \texttt{Provides: libfoo.so.1~= set:...}, а у программ~---
\texttt{Reqruies: libfoo.so.1~>=~set:...} (где вместо троеточия идет закодированная
последовательность хешей).  При сравнении таких \textit{set-версий} rpm выполняет проверку
$R\subseteq P$.

После этого было реализовано автоматическое создание \verb|debuginfo|-пакетов,
а пакеты в репозитории стали компилироваться с флагом \verb|-g|~--- с отладочной информацией
в формате DWARF.  Там содержится описание переменных и функций, в том числе аргументов
функций и их типов.  Используя эту информацию, символы можно наделить \textit{типом};
тогда при сравнении множеств будет проверяться не только разрешимость символов по имени,
но и совпадение их типов (для функций~--- прототипов).  Это напоминает
декорирование имен (name mangling) в C++, где к имени функции добавляется информация
об аргументах.  В обоих случаях типизация является \textit{атомарной}: возможно только
полное совпадение; никакой дальнейшей структуры в типизированных символах не усматривается.
Если символ меняет свой тип, хотя бы и условно совместимым образом, то образуется другой,
новый символ (с другим хешем).

Для языка Си полный учет типов порождает довольно жесткую конструкцию.  Если тип
изменяется условно совместимым образом, то желательно, чтобы символ остался прежним.
Далее обсуждается, какой может быть \textit{облегченная} типизация.  Показано,
что для реализации сборка с флагом \verb|-g| требуется только для библиотек.
Однако сборка приложений с флагом \verb|-g| открывает интересные возможности
для \textit{дополнительной} типизации.

\section{Типизация}
Допустим, функция принимает аргумент типа \verb|int|; а в новой версии тип аргумента
меняется на \verb|long|.  При этом функция сохраняет совместимость: ведь на 32-битных
архитектурах \verb|int| и \verb|long|~--- это один и тот же тип.  На 64-битных архитектурах
это два разных типа (32 и 64-битный), но при передаче параметра фактически используется
64-битный тип~--- либо за счет передачи через регистр, либо за счет выравнивания на стеке
\cite[с.\,23]{AMD64ABI}.
\begin{comment}
При этом возникает хороший вопрос: а не будет у нас мусора в старших битах?
По крайней мере на x86-64 мусора не появляется, потому что "mov eax" автоматически
очищает старшие биты.  Проверим, насколько серьезна проблема мусора в других случаях:
\begin{verbatim}
$ cat lib.c
#include <stdio.h>
void func(LIB_TYPE arg) { printf("%ld\n", (long) arg); }
$ cat main.c
extern void func(MAIN_TYPE arg);
int main() { func(666); return 0; }
$ gcc -m32 -DMAIN_TYPE=short -DLIB_TYPE=int -O main.c lib.c && ./a.out
666
\end{verbatim}
Вроде нету мусора.
\end{comment}
Аналогично, при добавлении или удалении спецификатора \verb|unsigned|
шансы нормального вызова остаются высокими.  Поэтому любой целочисленный
аргумент наделяется типом \verb|i|.

Рассмотрим теперь квалификатор \verb|const| вместе с аргументом типа \verb|char *| (Си-строка).
При добавлении квалификатора совместимость сохраняется полностью, а при удалении совместимость
ухудшается.
\begin{comment}
А может мы вообще должны были писать в эту строку, т.е. она была out-параметром?
С какой радости тогда "совместимость сохраняется"?  Мы думали нам запишут в строку,
а ее вместо этого берут как \verb|const|, смотрят что там в ней есть интересного.
\end{comment}
Мы сейчас выполнили \textit{структурное сравнение} на совместимость, которое противоречит
принципу атомарности.  Ничего не остается, как только полностью исключить квалификатор \verb|const|
из рассмотрения, признав его несущественным.  Но можно привести и другие аргументы в поддержку
этого решения.
Использование \verb|const| часто вызывает затруднения (кроме простейших случаев),
см. напр. о типе \verb|argv| в \verb|getopt(3)|.
В других языках вместо \verb|const| используется явное задание in/out параметров.
В третьих языках, таких как Rust, отслеживается владение (ownership) объектами.
Нам не хотелось бы признавать истинной ту или иную языковую абстракцию и проверять
бинарную совместимость в соответствии с ее догмами.
\begin{comment}
Тем более что в языке Си строковые литералы имеют типа char[].
Но модифицировать этот char строго запрещается, хотя он и не const.
Хреновые догмы какие-то, хуже Халкидонских канонов.
\end{comment}

Рассмотрим типизацию структур, передающихся по значению.  У структуры часто бывает
два имени: тег структуры и короткое имя, заданное через \verb|typedef|.  Но с точки
зрения бинарной совместимости вообще не следует привязываться к имени.  Поэтому
структуры наделяются типом \verb|bN|, где \verb|N|~--- размер структуры (\verb|sizeof|).

Массивы типизируются как \verb|aT|, где \verb|T|~--- тип элемента массива (это касается
только глобальных переменных; в параметрах массив преобразуется в указатель).

Указатели тоже хотелось бы типизировать как \verb|pT|; однако, в отличие от массивов,
тип \verb|T| может быть непрозрачным (opaque).  Кроме того, тип может быть полностью
скрыт указателем \verb|void *|.  Получается, почти все указатели на данные должны
иметь тип \verb|p|; можно лишь учитывать уровень косвенности (тогда, например,
аргумент \verb|char *argv[]| будет иметь тип \verb|pp|).  Кроме того, указатели
на функции можно типизировать полностью.  В качестве примера рассмотрим
функцию \verb|signal(3)|:
\begin{verbatim}
    typedef void (*sighandler_t)(int);
    sighandler_t signal(int signum, sighandler_t handler);
\end{verbatim}
Соответствующий ей символ наделяется типом так:
\begin{verbatim}
    signal (i, p(i)) -> p(i)
\end{verbatim}
\begin{comment}
Это что же получается если бы handler возвращал значение, то было бы две стрелки,
потипа right associative?  И точно ли никакой глупости не может быть с этими стрелками?
\end{comment}

\section{Сопоставление}
Как и в имеющейся реализации, для сопоставления требуемых символов с предоставляемыми
используется загрузчик \verb|ld.so|~--- он запускается в специальном отладочном режиме,
похожим на \verb|ldd(1)|.  Каждый требуемый символ наделяется типом
соответствующего предоставляемого символа; подразумевается, что на стадии сборки
типы символов соответствуют (по этой причине не требуется сборки клиентского кода
с отладочной информацией).
\begin{comment}
Формат DWARF, кажется, вообще не предусматривает подробного описания вызова функций
(приведение фактических параметров к формальным и т.\,п.).
То есть нету там такого дела, чтобы было написано: дескать прямо перед вызовом
функции foo() я вижу ее так-то, передаю ей такие-то аргументы, для некоторых
из них выполняется cast.
\end{comment}

Однако такое сопоставление нельзя считать слабым местом всей конструкции.  Сборка
пакетов является моментом \textit{наибольшего согласования} между клиентским и библиотечным
кодом; при наличии несовместимости код не соберется, либо не отработает \texttt{make check}.
Можно даже сказать, что одна из главных задач системы управления пакетами~--- это
\emph{перенос гарантий}, достигнутых во время сборки, на другие конфигурации.
А именно, с помощью бинарных зависимостей мы пытаемся гарантировать, что
при запуске программы символы будут разрешаться в некотором смысле
\emph{не хуже}, чем во время сборки.  Логично, что в обоих случаях используется
загрузчик \verb|ld.so|.
\begin{comment}
Вообще само понятие бинарной совместимости следовало бы определить прежде всего
исходя из этих терминов.  Если так подумать, то никакой другой бинарной совместимости
просто больше и нету.  Ну если не брать совсем какие-нибудь высоколобые определения
про семантику и т.п.  А если брать попроще, то вот сразу после сборки программа
у нас работала.  И мы пытаемся "удержать" вокруг этой программы какие-то свойства
сборочной среды, чтобы она и дальше работала.  А если программа перестает работать,
то значит все, совместимость удержать не удалось, упустили мы бабу, то есть жарптицу
всмысле.  Птицу счастья завтрашнего дня.  Сегодня программа работает, а завтра она глючит.
Поль Мориа, любовь ушла.
\end{comment}

\section{Дополнительная типизация}

\begin{thebibliography}{9}

\bibitem{Tourbin2010}
Алексей Турбин.  Комплементарное хеширование подмножеств~//
Седьмая конференция разработчиков свободных программ.
Тезисы докладов. М.,~2010. С.\,63--66.

\bibitem{Putze2007}
Felix Putze, Peter Sanders, Johannes Singler (2007)\\
Cache-, Hash- and Space-Efficient Bloom Filters

\bibitem{AMD64ABI}
Michael Matz et al.  System V Application Binary Interface.\\
AMD64 Architecture Processor Supplement.  Draft Version 0.99.7

\bibitem{dsohowto}
Ulrich Drepper. How To Write Shared Libraries\\
\url{www.akkadia.org/drepper/dsohowto.pdf}

\end{thebibliography}

\end{document}
