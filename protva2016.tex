\documentclass[russian,a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{url}
\usepackage{fullpage}

\sloppy
\hyphenpenalty=666

\begin{document}
\title{Типизация ABI}
\author{Алексей Турбин}
\date{21 сентября 2016 г.}
\maketitle

\begin{abstract}
Имеющаяся реализация бинарных зависимостей на основе set-версий
позволяет контролировать наличие нужных символов в библиотеках.
Показано, что реализация может быть расширена таким образом,
чтобы учитывался и тип символа, а не только его имя; так чтобы
обеспечивалось не только наличие нужных функций, но и совместимость
их прототипов.
\end{abstract}

\section{Введение}
В предыдущей % неоплаченной
работе \cite{Tourbin2010} показано, что понятие \textit{обратной совместимости}
часто является обманчивым; для достижения реальной \textit{бинарной
совместимости} между библиотеками и программами (ABI) нужно контролировать
не только и не столько придуманные версии библиотек, сколько \textit{разрешимость символов}
(т.\,е. фактическое наличие нужных функций в библиотеках).  Там же обсуждается, насколько
компактным может быть вероятностное представление множеств, при котором каждый
символ представлен $n$-битным хешем.  Вскоре был найден и способ кодирования:
\textit{код Голомба--Райса} обеспечивает оптимальное сжатие дельт (расстояний)
между соседними хешами \cite{Putze2007}.  Таким образом, у библиотек в репозитории появились
зависимости вида \texttt{Provides: libfoo.so.1~= set:...}, а у программ~---
\texttt{Reqruies: libfoo.so.1~>=~set:...} (где вместо троеточия идет закодированная
последовательность хешей).  При сравнении таких \textit{set-версий} rpm выполняет проверку
$R\subseteq P$.

После этого было реализовано автоматическое создание \verb|debuginfo|-пакетов,
а пакеты в репозитории стали компилироваться с флагом \verb|-g|~--- с отладочной информацией
в формате DWARF.  Там содержится описание переменных и функций, в том числе аргументов
функций и их типов.  Используя эту информацию, символы можно наделить \textit{типом};
тогда при сравнении множеств будет проверяться не только разрешимость символов по имени,
но и совпадение их типов (для функций~--- прототипов).  Это напоминает
декорирование имен (name mangling) в C++, где к имени функции добавляется информация
об аргументах.  В обоих случаях типизация является \textit{атомарной}: возможно только
полное совпадение; никакой дальнейшей структуры в типизированных символах не усматривается.
Если символ меняет свой тип, хотя бы и условно совместимым образом, то образуется другой,
новый символ (с другим хешем).

Для языка Си полный учет типов порождает довольно жесткую конструкцию.  Если тип
изменяется условно совместимым образом, то желательно, чтобы символ остался прежним.
Далее обсуждается, какой может быть \textit{облегченная} типизация.  Показано,
что для реализации сборка с флагом \verb|-g| требуется только для библиотек.
Однако сборка приложений с флагом \verb|-g| открывает интересные возможности
для \textit{дополнительной} типизации.

\section{Типизация}
\section{Сопоставление}
\section{Дополнительная типизация}

\begin{thebibliography}{9}

\bibitem{Tourbin2010}
Алексей Турбин.  Комплементарное хеширование подмножеств~//
Седьмая конференция разработчиков свободных программ.
Тезисы докладов. М.,~2010. С.\,63--66.

\bibitem{Putze2007}
Felix Putze, Peter Sanders, Johannes Singler (2007)\\
Cache-, Hash- and Space-Efficient Bloom Filters

\bibitem{dsohowto}
Ulrich Drepper. How To Write Shared Libraries\\
\url{www.akkadia.org/drepper/dsohowto.pdf}

\end{thebibliography}

\end{document}
